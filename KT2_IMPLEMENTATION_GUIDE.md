# The Koppeltaal implementation Guide

## Introduction
The Koppeltaal 2.0 implementation guide provides a guide for engineers, architects and product owners. This guide attempts to explain in what to expect when implementing Koppeltaal 2.0.


## Scope and domain
Depending on your application architecture, you must be aware that koppeltaal is deployed in the context of a domain. In case of a multi-tenant solution, you must be aware of the fact that most of the things you need will be domain specific and the architecture you choose must cater for this. If you are starting your application architecture from scratch you might want to consider a deployment-per-domain strategy and simplify your application architecture. However, such e per-domain deployment strategy might hinder the replication of content between installations. 


## Security and permission model

### Trust model explained
Koppeltaal uses a *application* level trust model, so applications get a role with a set of permissions that give access to FHIR resources. In koppeltaal, the individual user of the system are NOT identified, it is the responsibility of the application to enforce user level restrictions. Applications are assigned roles, koppeltaal uses a form of Role-Based Access Control (RBAC). 
The trust model is based on a central authority in the koppeltaal domain, the authorization service, to which all access related tasks are delegated to. The authorization service hands out access to the API, validates launches and provides token introspection. 


#### Key pairs and secrecy
In order to participate in a domain, an application needs to generate a keypair and publish the public part by JWKS. The secret leg of the keypair must be kept secret. If the private part is leaked, others can easily take over your application role in the domain. By making use of JWKS it is make possible to have multiple key pairs active and change key pairs with minimal effort. It is advised to not store and share the private keys, instead to keep the private part in memory and disseminate the public part by JWKS.
#### Public key sharing
The public keys should be published by providing a JWKS URL to the koppeltaal domain. This URL contains a list of public keys identified by Key ID's (kid). These Key ID's must match the kid header of the JWTs that are generated by the application to identify itself. This JWKS URL is a way of publishing the verifications methods of the application. The URL must be public accessible. It is discouraged to use a common or well-known URL path for this URL.
#### Roles & permissions
Applications in a domain get assigned a role by the domain administrator. This role is built up out of permissions to resources. These permissions are expressed in <resource-type>.<action>.<scope> format.
1. Resource: linked to a FHIR resource type.
2. Action: a set if Create (C), Read (R), Update (U) of Delete (D) actions.
3. Scope: one of the following:
   * OWN: access your own resources.
   * GRANTED: a list of applications
   * ALL: all resources.
The "ownership" of a resource is defined by the resource-origin extention field. This field refers to the Device of the owning application. 
#### Delegated trust
Trust delegation to the auth service




## Accessing the API
### Getting access: generating a JWT to identify yourself
### CRUD operations & versioning
Base FHIR resources, refer to FHIR API
### Lifecycle entities
Explain that entities have a lifecycle.
#### Deletion
Explains soft vs hard delete
#### Handling errors and logging
Explain how the logging works and how errors should be logged.

## Get notified on changes
### Subscriptions
### Logging and tracing headers

## Launching
### Executing a launch
### Receiving a launch
### Logging and tracing


## The implementation checklist

1. Generate and securely retain public/private keypairs
2. Be able publish the public keys in a JWKS endpoint
3. Develop the logic to generate a JWT to identify your application to the auth service.
4. Request an access_token to access the API.
5. Be able to work with FHIR entities
6. Understand the lifecycle of FHIR entities
7. Synchronization and errors
8. Staring a launch: generating a JWT
9. Receiving a launch: execute the SMART on FHIR sequence.



